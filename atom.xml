<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄大仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-23T09:06:47.199Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄大仁</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.JUC/OldPaper/Future/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/5.JUC/OldPaper/Future/</id>
    <published>2019-02-21T03:42:05.530Z</published>
    <updated>2019-01-23T09:06:47.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。</p><p>这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p><p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><p><strong>Interface</strong></p><p>Future代表一次异步计算的结果，它提供方法来查看计算是否完成、获取计算结果、取消计算。</p><table><thead><tr><th>方法与描述</th></tr></thead><tbody><tr><td><code>cancel(boolean mayInterruptIfRunning)</code>尝试取消执行该任务</td></tr><tr><td><code>get()</code>一直等待直到任务完成</td></tr><tr><td><code>get(long timeout, TimeUnit unit)</code>最多等待指定的时间</td></tr><tr><td><code>isCancelled()</code>是否成功取消该任务</td></tr><tr><td><code>isDone()</code>任务是否已完成</td></tr></tbody></table><h2 id="ScheduledFuture"><a href="#ScheduledFuture" class="headerlink" title="ScheduledFuture"></a>ScheduledFuture</h2><p><strong>Interface</strong></p><p>A delayed result-bearing action that can be cancelled. Usually a scheduled future is the result of scheduling a task with a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener"><code>ScheduledExecutorService</code></a>.</p><h2 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h2><p><strong>Interface</strong></p><p>一个Runnable的Future，在成功执行玩run方法后，可以获取其结果。</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>Future接口的基本实现。</p><h3 id="RunnableScheduledFuture"><a href="#RunnableScheduledFuture" class="headerlink" title="RunnableScheduledFuture"></a>RunnableScheduledFuture</h3><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledFuture.html" target="_blank" rel="noopener"><code>ScheduledFuture</code></a> that is <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener"><code>Runnable</code></a>. Successful execution of the <code>run</code> method causes completion of the <code>Future</code> and allows access to its results.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;Future&quot;&gt;&lt;/a&gt;Future&lt;/h1&gt;&lt;p&gt;在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.JUC/OldPaper/3.Executor/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/5.JUC/OldPaper/3.Executor/</id>
    <published>2019-02-21T03:42:05.530Z</published>
    <updated>2019-01-23T08:52:39.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><p>执行用户提交上来的任务（Runnable）。该接口提供了一种方法来对任务的提交和任务的运行机制进行解耦。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>Executor，提供管理终止的方法和可以生成Future以跟踪一个或多个异步任务进度的方法。</p><p>ExecutorService是可以关闭，这将导致它拒绝新任务。有两种方法关闭它。shutdown（）方法将允许先前提交的任务在终止之前执行，而shutdownNow（）方法则阻止等待任务启动并尝试停止当前正在执行的任务。 终止时，执行程序没有正在执行的任务，没有等待执行的任务，也没有任何新任务可以提交。 应关闭未使用的ExecutorService以允许回收其资源。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>一个ExecutorService，通过线程池来进行用户提交的任务。</p><h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>一个ExecutorService，等待给定的时间后执行命令或者定期执行。</p><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>一个ThreadPoolExecutor，等待给定的时间后执行命名或者定期执行。</p><h1 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h1><h2 id="ThreadPoolExecutor-1"><a href="#ThreadPoolExecutor-1" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>类是Java线程池的核心类。</p><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><code>ThreadPoolExecutor</code> &gt;&gt; <code>AbstractExecutorService</code> &gt;&gt; <code>ExecutorService</code> &gt;&gt;<code>Executor</code></p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 他有四个构造器</span></span><br><span class="line"><span class="comment">  * corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">  * maximumPoolSize 最大线程池大小</span></span><br><span class="line"><span class="comment">  * keepAliveTime 当前线程数量大于核心数时，空闲的线程可以存活多久</span></span><br><span class="line"><span class="comment">  * unit keepAliveTime的单位</span></span><br><span class="line"><span class="comment">  * workQueue </span></span><br><span class="line"><span class="comment">  * ThreadFactory 线程工厂</span></span><br><span class="line"><span class="comment">  * handler</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>在ThreadPoolExecutor类中有几个非常重要的方法：</p><ul><li><p>execute()</p><p>execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p></li><li><p>submit()</p><p>submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。</p></li><li><p>shutdown()</p></li><li><p>shutdownNow()</p><p>尝试停止正在执行的任务，返回等待执行的任务。</p></li></ul><h2 id="深入线程池"><a href="#深入线程池" class="headerlink" title="深入线程池"></a>深入线程池</h2><h3 id="任务缓存队列及排队策略"><a href="#任务缓存队列及排队策略" class="headerlink" title="任务缓存队列及排队策略"></a>任务缓存队列及排队策略</h3><p>在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。</p><p>workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：</runnable></p><p>　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p><p>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p><h3 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h3><p>当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p><ul><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常</li><li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ul><h3 id="线程池容量的动态调整"><a href="#线程池容量的动态调整" class="headerlink" title="线程池容量的动态调整"></a>线程池容量的动态调整</h3><p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，</p><ul><li>setCorePoolSize：设置核心池大小</li><li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</li></ul><p>当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Java并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();       <span class="comment">//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span></span><br><span class="line">Executors.newSingleThreadExecutor();   <span class="comment">//创建容量为1的缓冲池</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="keyword">int</span>);     <span class="comment">//创建固定容量大小的缓冲池</span></span><br><span class="line"><span class="comment">// 上面三个方法都是使用ThreadPoolExecutor来创建线程池</span></span><br><span class="line">newScheduledThreadPool(<span class="keyword">int</span>);</span><br><span class="line">newWorkStealingPool(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Executor&quot;&gt;&lt;a href=&quot;#Executor&quot; class=&quot;headerlink&quot; title=&quot;Executor&quot;&gt;&lt;/a&gt;Executor&lt;/h1&gt;&lt;p&gt;执行用户提交上来的任务（Runnable）。该接口提供了一种方法来对任务的提交和任务的运行机
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.JUC/OldPaper/2.Future/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/5.JUC/OldPaper/2.Future/</id>
    <published>2019-02-21T03:42:05.530Z</published>
    <updated>2019-01-23T08:17:41.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。</p><p>这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p><p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><p><strong>Interface</strong></p><p>Future代表一次异步计算的结果，它提供方法来查看计算是否完成、获取计算结果、取消计算。</p><table><thead><tr><th>方法与描述</th></tr></thead><tbody><tr><td><code>cancel(boolean mayInterruptIfRunning)</code>尝试取消执行该任务</td></tr><tr><td><code>get()</code>一直等待直到任务完成</td></tr><tr><td><code>get(long timeout, TimeUnit unit)</code>最多等待指定的时间</td></tr><tr><td><code>isCancelled()</code>是否成功取消该任务</td></tr><tr><td><code>isDone()</code>任务是否已完成</td></tr></tbody></table><h2 id="ScheduledFuture"><a href="#ScheduledFuture" class="headerlink" title="ScheduledFuture"></a>ScheduledFuture</h2><p><strong>Interface</strong></p><p>A delayed result-bearing action that can be cancelled. Usually a scheduled future is the result of scheduling a task with a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener"><code>ScheduledExecutorService</code></a>.</p><h2 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h2><p><strong>Interface</strong></p><p>一个Runnable的Future，在成功执行玩run方法后，可以获取其结果。</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>Future接口的基本实现。</p><h3 id="RunnableScheduledFuture"><a href="#RunnableScheduledFuture" class="headerlink" title="RunnableScheduledFuture"></a>RunnableScheduledFuture</h3><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledFuture.html" target="_blank" rel="noopener"><code>ScheduledFuture</code></a> that is <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener"><code>Runnable</code></a>. Successful execution of the <code>run</code> method causes completion of the <code>Future</code> and allows access to its results.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;Future&quot;&gt;&lt;/a&gt;Future&lt;/h1&gt;&lt;p&gt;在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.JUC/OldPaper/1.Callable/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/5.JUC/OldPaper/1.Callable/</id>
    <published>2019-02-21T03:42:05.530Z</published>
    <updated>2019-01-23T08:28:19.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><p>一个可以返回结果和抛出异常的任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h1&gt;&lt;p&gt;一个可以返回结果和抛出异常的任务。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.JUC/OldPaper/ExecutorServiceAndThreadPool/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/5.JUC/OldPaper/ExecutorServiceAndThreadPool/</id>
    <published>2019-02-21T03:42:05.530Z</published>
    <updated>2019-01-23T10:29:49.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Executors框架"><a href="#Executors框架" class="headerlink" title="Executors框架"></a>Executors框架</h1><p>前面我们已经学了如何通过继承Thread类或者实现Runnable接口来创建线程。</p><p>如果只是创建几个线程还好，如果要创建的线程数量比较多，那么这种不断创建和销毁线程的方法，其实是大大降低对系统资源的利用度的。</p><p>为了解决这个问题，JDK为我们提供了Executor框架，一个用来创建和管理线程的框架。</p><p>Executor框架具有以下的作用：</p><ul><li>创建线程：它提供了多种方法来创建线程，具体来说就是使用线程池维护线程，从线程池调用线程执行任务。</li><li>线程管理：通过线程池来维护线程的生命周期。</li><li>任务的提交与执行：它不仅提供了方法让你提交任务，还能让你决定任务是马上执行，还是延迟执行，甚至定期执行。</li></ul><p>JUC提供了以下三个接口，这三个接口定义所有创建和管理线程所需要的方法。</p><ul><li><strong>Executor</strong>：一个只包含<code>execute（）</code>方法的接口，通过接收一个<code>runnable</code>对象来执行任务。</li><li><strong>ExecutorService</strong>：<strong>Executor</strong>的子接口，添加了管理任务生命周期的功能。同时还提供了<code>submit()</code>方法可以接收<code>Runnable</code>和<code>Callable</code>对象。<code>Callable</code>与<code>Runnable</code>类似，只不过前者可以返回执行后的结果。</li><li><strong>ScheduledExecutorService</strong>：<strong>ExecutorService</strong>的子接口，It adds functionality to schedule the execution of the tasks.</li></ul><p>除了上面三个接口，JUC还提供了一个<code>Executors</code>类，提供了一些工厂方法来创建不同类型的<strong>ExecutorService</strong>。</p><h2 id="ExecutorService-Example"><a href="#ExecutorService-Example" class="headerlink" title="ExecutorService Example"></a>ExecutorService Example</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Creating Executor Service..."</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Creating a Runnable..."</span>);</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Submit the task."</span>);</span><br><span class="line">        executorService.submit(runnable);</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"Shutting down the executor"</span>);</span><br><span class="line">  executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Creating Executor Service with a thread pool of Size 2"</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Runnable task1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Executing Task1 inside : "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable task2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Executing Task2 inside : "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable task3 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Executing Task3 inside : "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Submitting the tasks for execution..."</span>);</span><br><span class="line">        executorService.submit(task1);</span><br><span class="line">        executorService.submit(task2);</span><br><span class="line">        executorService.submit(task3);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ScheduledExecutorService-example"><a href="#ScheduledExecutorService-example" class="headerlink" title="ScheduledExecutorService example"></a>ScheduledExecutorService example</h2><p>ScheduledExecutorService用来定期或者延期执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">   Runnable task = () -&gt; System.out.println(<span class="string">"老婆听电话！"</span>);</span><br><span class="line">   executorService.schedule(task, <span class="number">2</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">   Runnable task = () -&gt; System.out.println(<span class="string">"老婆听电话！"</span>);</span><br><span class="line">   executorService.scheduleAtFixedRate(task, <span class="number">2</span>, <span class="number">2</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Callable-And-Future"><a href="#Callable-And-Future" class="headerlink" title="Callable And Future"></a>Callable And Future</h1><p>在上面的例子，我们都是使用<code>Runnable</code>对象来定义任务，这种方法很方便，但是有个缺陷，那就是它不能返回任务执行后的结果。</p><p>JDK为我们提供了<code>Callable</code>接口用它来定义的任务，可以在执行完毕后返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">      <span class="comment">// Perform some computation</span></span><br><span class="line">      System.out.println(<span class="string">"Entered Callable"</span>);</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Hello from Callable"</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">   Future&lt;String&gt; result = executorService.submit(task);</span><br><span class="line">   <span class="comment">// Future.get() blocks until the result is available</span></span><br><span class="line">   String s = result.get();</span><br><span class="line">   System.out.println(s);</span><br><span class="line">   executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Executors框架&quot;&gt;&lt;a href=&quot;#Executors框架&quot; class=&quot;headerlink&quot; title=&quot;Executors框架&quot;&gt;&lt;/a&gt;Executors框架&lt;/h1&gt;&lt;p&gt;前面我们已经学了如何通过继承Thread类或者实现Runnable接
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.JUC/tools/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/5.JUC/tools/</id>
    <published>2019-02-21T03:42:05.526Z</published>
    <updated>2019-01-26T10:43:54.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>一个同步辅助工具，允许一个或多个线程处于等待直到其它线程中执行的一组操作完成。</p><p>构造CountDownLatch的时候需要给定一个计数量（count），每次调用countDown()方法就会减少一次，当计量数为0的时候，唤醒所有等待中的线程。</p><table><thead><tr><th></th><th>方法和描述</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>await()</code>Causes the current thread to wait until the latch has counted down to zero, unless the thread is <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--" target="_blank" rel="noopener">interrupted</a>.</td></tr><tr><td><code>boolean</code></td><td><code>await(long timeout, TimeUnit unit)</code>Causes the current thread to wait until the latch has counted down to zero, unless the thread is <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--" target="_blank" rel="noopener">interrupted</a>, or the specified waiting time elapses.</td></tr><tr><td><code>void</code></td><td><code>countDown()</code>Decrements the count of the latch, releasing all waiting threads if the count reaches zero.</td></tr><tr><td><code>long</code></td><td><code>getCount()</code>Returns the current count.</td></tr><tr><td><code>String</code></td><td><code>toString()</code>Returns a string identifying this latch, as well as its state.</td></tr></tbody></table><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">     Executor e = ...</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">       e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">     doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">   WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">     <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">     <span class="keyword">this</span>.i = i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       doWork(i);</span><br><span class="line">       doneSignal.countDown();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>允许一组线程全部等待彼此到达共同的障碍点。</p><p>CyclicBarrier支持可选的Runnable命令，该命令在每个障碍点运行一次，在聚会中的最后一个线程到达之后，但在释放任何线程之前。</p><table><thead><tr><th></th><th>方法和描述</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>await()</code>Waits until all <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html#getParties--" target="_blank" rel="noopener">parties</a> have invoked <code>await</code> on this barrier.</td></tr><tr><td><code>int</code></td><td><code>await(long timeout, TimeUnit unit)</code>Waits until all <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html#getParties--" target="_blank" rel="noopener">parties</a> have invoked <code>await</code> on this barrier, or the specified waiting time elapses.</td></tr><tr><td><code>int</code></td><td><code>getNumberWaiting()</code>Returns the number of parties currently waiting at the barrier.</td></tr><tr><td><code>int</code></td><td><code>getParties()</code>Returns the number of parties required to trip this barrier.</td></tr><tr><td><code>boolean</code></td><td><code>isBroken()</code>Queries if this barrier is in a broken state.</td></tr><tr><td><code>void</code></td><td><code>reset()</code>Resets the barrier to its initial state.</td></tr></tbody></table><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    available.acquire();</span><br><span class="line">    <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">      available.release();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">         used[i] = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">return</span> items[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">           used[i] = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h1><p>此包中定义的Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类的工厂和实用方法。</p><p>该类支持以下几种方法：</p><ul><li>Methods that create and return an <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener"><code>ExecutorService</code></a> set up with commonly useful configuration settings.</li><li>Methods that create and return a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener"><code>ScheduledExecutorService</code></a> set up with commonly useful configuration settings.</li><li>Methods that create and return a “wrapped” ExecutorService, that disables reconfiguration by making implementation-specific methods inaccessible.</li><li>Methods that create and return a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadFactory.html" target="_blank" rel="noopener"><code>ThreadFactory</code></a> that sets newly created threads to a known state.</li><li>Methods that create and return a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html" target="_blank" rel="noopener"><code>Callable</code></a> out of other closure-like forms, so they can be used in execution methods requiring <code>Callable</code>.</li></ul><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h1&gt;&lt;p&gt;一个同步辅助工具，允许一个或多个线程处于等待
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/x.JMM/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/x.JMM/</id>
    <published>2019-02-21T03:42:05.522Z</published>
    <updated>2019-01-15T01:06:14.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-并行、并发、高并发、线程安全性"><a href="#1-并行、并发、高并发、线程安全性" class="headerlink" title="1.并行、并发、高并发、线程安全性"></a>1.并行、并发、高并发、线程安全性</h1><p><strong>并行、并发、高并发</strong></p><p><strong>并行</strong>：如果某个系统支持两个或以上个动作<strong>同时存在</strong>，那么这个系统就是一个<strong>并发系统</strong>。<br><strong>并发</strong>：如果某个系统支持两个或以上个动作<strong>同时执行</strong>，那么这个系统就是一个<strong>并行系统</strong>。</p><p>并发系统与并行系统这两个定义之间的关键差异在于<strong>“执行”</strong>这个词。<br>在并发程序中可以同时拥有两个或以上个线程。这意味着，如果程序在单核处理器上运行，那么这些线程将交替的执行。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。<br>如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p><p><strong>高并发</strong>：通常是指，通过设计保证系统能够<strong>同时并行处理</strong>很多请求。</p><p><strong>线程安全性</strong>：一个类无论被多少个线程访问，该类始终能表现出正确的行为，那么就称这个类是线程安全的。</p><h1 id="2-并发编程的问题"><a href="#2-并发编程的问题" class="headerlink" title="2.并发编程的问题"></a>2.并发编程的问题</h1><p>在并发编程中，我们会遇到某些问题，例如原子性问题、可见性问题、有序性问题等等。</p><p>解决问题，我们要有方法论以及具体实现。在Java并发编程中，这个方法论就是Java内存模型，而具体实现就是Java提供的一系列和并发处理相关的关键字，比如<code>volatile</code>、<code>synchronized</code>、<code>final</code>以及<code>concurrent</code>包等等。</p><p>我们先来学习其中的方法论，再来学习具体实现。</p><p>Java内存模型，顾名思义就是一种内存模型，那么我们有必要先了解一下什么是内存模型。</p><h2 id="2-1内存模型"><a href="#2-1内存模型" class="headerlink" title="2.1内存模型"></a>2.1内存模型</h2><p><strong>内存模型的作用是定义共享内存的正确性。具体的做法就是内存模型提供了一些关于内存读写的规则。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。</strong></p><h3 id="2-1CPU缓存一致性"><a href="#2-1CPU缓存一致性" class="headerlink" title="2.1CPU缓存一致性"></a>2.1CPU缓存一致性</h3><p><strong>背景知识：CPU的高速缓存</strong></p><p>总所周知，CPU和内存并不是直接交换数据的，它们之间还隔着一个高速缓存。高速缓存是对程序员透明的，这意味在编程的时候是感知不到CPU的缓存的存在的。一般情况下确实如此，但在，在某些特殊的情形下（多核多线程），就不能忽略缓存的存在了。这其实是和缓存的设计有关系，一般多处理器下的每个CPU都有一个自己的缓存，存储在这个缓存的数据是其它CPU是无法查看的。</p><p><strong>引入问题1：缓存一致性</strong></p><p>问题来了，由于缓存是每个CPU私有的，那么在多线程环境下，某个CPU修改了变量x后保存在本地缓存，对于其它CPU，何时才能发现变量x被修改呢？如何保证其它CPU的缓存中持有的x的值是最新的呢？这就是缓存一致性问题。</p><p>缓存一致性问题是由于引入缓存而导致的，所以，这是很多CPU厂商必须解决的问题。为了解决前面提到的缓存数据不一致的问题，人们提出过很多方案，通常来说有以下2种方案：</p><ul><li>通过在总线加<code>LOCK#</code>锁的方式。</li><li>通过缓存一致性协议（Cache Coherence Protocol）。</li></ul><p><strong>LOCK#</strong></p><p>在早期的CPU当中，是通过在总线上加<code>LOCK#</code>锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加<code>LOCK#</code>锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。在总线上发出了<code>LCOK#</code>锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从其内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。但是由于在锁住总线期间，其他CPU无法访问内存，会导致效率低下。因此出现了第二种解决方案，通过缓存一致性协议来解决缓存一致性问题。</p><p><strong>缓存一致性协议</strong></p><p>缓存一致性协议（Cache Coherence Protocol），最出名的就是Intel 的MESI协议，MESI协议的作用就是保证每个缓存中使用的共享变量的副本是一致的。MESI的核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><p>在MESI协议中，每个缓存可能有有4个状态，它们分别是：</p><ul><li>M(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</li><li>E(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。</li><li>S(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。</li><li>I(Invalid)：这行数据无效。</li></ul><p>关于MESI的更多细节这里就不详细介绍了，我们只要知道，MESI是一种比较常用的缓存一致性协议，他可以用来解决缓存之间的数据一致性问题就可以了。</p><p>通过缓存一致性协议之后，内存可见性问题似乎是得以解决了。但是，这里面还隐藏着另外一个问题：乱序执行！</p><h3 id="2-1-2乱序执行"><a href="#2-1-2乱序执行" class="headerlink" title="2.1.2乱序执行"></a>2.1.2乱序执行</h3><p>乱序，指的是程序指令实际上执行的顺序，和我们书写的指令的顺序不一致。乱序分两种，分别是编译器的指令重排和CPU的乱序执行。本意上乱序是为了优化指令执行的速度而产生的。并且为了维护程序原来的语义，编译器和CPU不会对两个有数据依赖的指令重排（reorder）。这种保护在单线程的环境下是可以工作的，但是到了多线程，就可能出问题了。</p><p>举个例子，CPU-0将要执行两条指令，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. STORE x</span><br><span class="line">2. LOAD y</span><br></pre></td></tr></table></figure><p>当CPU-0执行指令1的时候，发现这个变量x的当前状态为Shared，这意味着其它CPU也持有了x，因此根据缓存一致性协议，CPU-0在修改x之前必须通知其它CPU，直到收到来自其它CPU的ack才会执行真正的修改x。但是，事情没有这么简单。现代CPU缓存通常都有一个Store Buffer，其存在的目的是，先将要Store的变量记下来，注意此时并不真的执行Store操作，然后待时机合适的时候再执行实际的Store。有了这个Store Buffer，CPU-0在向其它CPU发出disable消息之后并不是干等着，而是转而执行指令2（由于指令1和指令2在CPU-0看来并不存在数据依赖）。这样做效率是有了，但是也带来了问题。虽然我们在写程序的时候，是先STORE x再执行LOAD y，但是实际上CPU却是先LOAD y再STORE x，这个便是CPU乱序执行（reorder）的一种情况！</p><p>当你的程序要求指令1、2有逻辑上的先后顺序时，CPU这样的优化就是有问题的。但是，CPU并不知道指令之间蕴含着什么样的逻辑顺序，在你告诉它之前，它只是假设指令之间都没有逻辑关联，并且尽最大的努力优化执行速度。因此我们需要一种机制能告诉CPU：这段指令执行的顺序是不可被重排的！做这种事的就是内存屏障（memory barrier）！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STORE x</span><br><span class="line">WMB (Write memory barrier)</span><br><span class="line">LOAD y</span><br></pre></td></tr></table></figure><p>例如，通过在STORE x之后加上这个写内存屏障，就能保证在之后LOAD y指令不会被重排到STORE x之前了。</p><h3 id="2-1-3总结"><a href="#2-1-3总结" class="headerlink" title="2.1.3总结"></a>2.1.3总结</h3><p>前面讲了那么多，那么内存模型是什么呢？由于每个CPU设计都是不同的，每个CPU对指令乱序的程度也是不一样的。比较保守的如x86仅会对Store Load乱序，但是一些优化激进的CPU（PS的Power）会允许更多情况的乱序产生。如果目标是写一个跨平台多线程的程序，那么势必要了解每一个CPU的细节，来插入确切的、足够的内存屏障来保证程序的正确性。这是多么的不科学啊！科学的做法应该是，编写一套抽象的程序，然后在不同的平台下让编程语言、编译器来生成合适的内存屏障以及处理缓存一致性问题。因此，我们有了内存模型的概念。我们只需要根据这个抽象的内存模型来编写程序即可。</p><h2 id="2-2原子性、可见性、有序性"><a href="#2-2原子性、可见性、有序性" class="headerlink" title="2.2原子性、可见性、有序性"></a>2.2原子性、可见性、有序性</h2><ul><li><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li><strong>原子性</strong>：指在一个操作中cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</li><li><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。</li></ul><p>有没有发现，<strong>缓存一致性问题</strong>其实就是<strong>可见性问题</strong>。<strong>CPU乱序执行</strong>就是<strong>原子性问题</strong>，<strong>编译器指令重排</strong>就是<strong>有序性问题</strong>。所以说Java内存模型是解决这些问题的方法论。</p><h1 id="3-Java内存模型"><a href="#3-Java内存模型" class="headerlink" title="3.Java内存模型"></a>3.Java内存模型</h1><h2 id="3-1什么是Java内存模型"><a href="#3-1什么是Java内存模型" class="headerlink" title="3.1什么是Java内存模型"></a>3.1什么是Java内存模型</h2><p><strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p><p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">JSR-133: JavaTM Memory Model and Thread Specification</a> 描述。</p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存保存了主内存中该线程使用到的变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><h2 id="3-2Java内存模型的实现"><a href="#3-2Java内存模型的实现" class="headerlink" title="3.2Java内存模型的实现"></a>3.2Java内存模型的实现</h2><p>在Java中提供了一系列和并发处理相关的关键字，比如<code>volatile</code>、<code>synchronized</code>、<code>final</code>等等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用<code>synchronized</code>等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，<strong>Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</strong></p><p>下面我们看看在Java中分别使用什么方式解决原子性、有序性和一致性等问题。</p><h3 id="3-2-1原子性问题"><a href="#3-2-1原子性问题" class="headerlink" title="3.2.1原子性问题"></a>3.2.1原子性问题</h3><ul><li>原子变量类</li><li>synchronized</li></ul><p>在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。在<a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">synchronized的实现原理</a>文章中，介绍过，这两个字节码，在Java中对应的关键字就是<code>synchronized</code>。因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p><h3 id="3-2-2可见性问题"><a href="#3-2-2可见性问题" class="headerlink" title="3.2.2可见性问题"></a>3.2.2可见性问题</h3><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><h3 id="3-2-3有序性问题"><a href="#3-2-3有序性问题" class="headerlink" title="3.2.3有序性问题"></a>3.2.3有序性问题</h3><p>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：</p><p><code>volatile</code>关键字会禁止指令重排。</p><p><code>synchronized</code>关键字保证同一时刻只允许一条线程操作。进出锁住的代码块是串行的，因为只能有一个线程拿到锁，这就使得使用同一个锁的两个执行过程A和B之间，A看B的操作是有序的，B看A的操作也是有序的，是因为执行过程内部无论会不会指令重排序，结果都是一致的。但是锁的内部代码依然会指令重排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-并行、并发、高并发、线程安全性&quot;&gt;&lt;a href=&quot;#1-并行、并发、高并发、线程安全性&quot; class=&quot;headerlink&quot; title=&quot;1.并行、并发、高并发、线程安全性&quot;&gt;&lt;/a&gt;1.并行、并发、高并发、线程安全性&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;并行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.JUC/locks/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/5.JUC/locks/</id>
    <published>2019-02-21T03:42:05.522Z</published>
    <updated>2019-01-26T02:25:16.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h1><p>我们知道，synchronized 是Java的关键字，是Java的内置特性，在JVM层面实现了对临界资源的同步互斥访问，但 synchronized 在处理实际问题时存在诸多局限性，比如响应中断等。Lock 提供了比 synchronized更广泛的锁操作，它能以更优雅的方式处理线程同步问题。</p><p>lock是控制多线程获取共享资源的工具，只有在获取到锁的情况下，才能对共享资源进行操作，而在同一个时间只能有一个线程获取到锁。当然也有些锁是运行并发获取共享资源的，例如ReadWriteLock中的读锁。</p><p>每个对象都藏有一个监视器锁（monitor lock），synchronized关键字就是用来获取这个锁的，synchronized要求对锁的占用和释放都必须在代码块或方法块中进行。这就导致synchronized用起来简单，但是它不够灵活，在某些情景下，我们需要更加灵活的锁。例如用于遍历并发访问的数据结构的一些算法需要使用“手动”或“链锁”：获取节点A的锁定，然后获取节点B，然后释放A并获取C，然后释放B并获取D等等。Lock接口的实现类允许在不同的作用域中获取和释放锁，还允许以任何的顺序获取或释放多个锁。</p><p>由于它允许你在不同的作用域使用锁，因此你需要手动的对锁进行释放。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Lock中声明了四个方法来获取锁，下面来讲讲这四个方法有何区别。</p><ul><li><p>lock()</p><p>用来获取锁。如果锁已被其他线程获取，则一直等待。</p></li><li><p>tryLock()tryLock()</p><p>尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p></li><li><p>tryLock(long time, TimeUnit unit)</p><p>和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p></li><li><p>lockInterruptibly()</p><p>获取锁，unless the current thread is <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--" target="_blank" rel="noopener">interrupted</a>.</p></li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是目前JUC中唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p><h3 id="ReentrantReadWriteLock-ReadLock"><a href="#ReentrantReadWriteLock-ReadLock" class="headerlink" title="ReentrantReadWriteLock.ReadLock"></a>ReentrantReadWriteLock.ReadLock</h3><p>The lock returned by method ReentrantReadWriteLock.readLock().</p><h3 id="ReentrantReadWriteLock-WriteLock"><a href="#ReentrantReadWriteLock-WriteLock" class="headerlink" title="ReentrantReadWriteLock.WriteLock"></a>ReentrantReadWriteLock.WriteLock</h3><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition接口可以让线程暂停执行，直到给定的条件（Condition）为真。</p><p>Lock用来代替synchronized，Condition用来代替Object的监控方法（wait, notify and notifyAll）。</p><table><thead><tr><th></th><th>方法和描述</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>await()</code>线程进入等待状态直到接收到信号或者被打断</td></tr><tr><td><code>boolean</code></td><td><code>await(long time, TimeUnit unit)</code>Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses.</td></tr><tr><td><code>long</code></td><td><code>awaitNanos(long nanosTimeout)</code>Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses.</td></tr><tr><td><code>void</code></td><td><code>awaitUninterruptibly()</code>线程进入等待状态直到接收到信号</td></tr><tr><td><code>boolean</code></td><td><code>awaitUntil(Date deadline)</code>Causes the current thread to wait until it is signalled or interrupted, or the specified deadline elapses.</td></tr><tr><td><code>void</code></td><td><code>signal()</code>Wakes up one waiting thread.</td></tr><tr><td><code>void</code></td><td><code>signalAll()</code>Wakes up all waiting threads.</td></tr></tbody></table><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock维护一对关联的锁，一个用于只读操作，另一个用于写入。只要没有写入，读锁定可以由多个读取器线程同时保持。写锁是独占的。</p><table><thead><tr><th></th><th>方法和描述</th></tr></thead><tbody><tr><td><code>Lock</code></td><td><code>readLock()</code>Returns the lock used for reading.</td></tr><tr><td><code>Lock</code></td><td><code>writeLock()</code>Returns the lock used for writing.</td></tr></tbody></table><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>ReadWriteLock的实现，支持与ReentrantLock类似的语义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><h3 id="concurrent包的基础"><a href="#concurrent包的基础" class="headerlink" title="concurrent包的基础"></a>concurrent包的基础</h3><p>Doug Lea 的神作concurrent包是基于AQS (AbstractQueuedSynchronizer)框架，AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)。因此，LockSupport可谓构建concurrent包的基础之一。理解concurrent包，就从这里开始。</p><h3 id="两个重点"><a href="#两个重点" class="headerlink" title="两个重点"></a>两个重点</h3><ul><li><strong>操作对象</strong></li></ul><p>归根结底，LockSupport调用的Unsafe中的native代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public native void unpark(Thread jthread); </span><br><span class="line">public native void park(boolean isAbsolute, long time);</span><br></pre></td></tr></table></figure><p>两个函数声明清楚地说明了操作对象：park函数是将当前Thread阻塞，而unpark函数则是将另一个Thread唤醒。</p><p>与Object类的wait/notify机制相比，park/unpark有两个优点：1. 以thread为操作对象更符合阻塞线程的直观定义；2. 操作更精准，可以准确地唤醒某一个线程（notify随机唤醒一个线程，notifyAll唤醒所有等待的线程），增加了灵活性。</p><ul><li><strong>关于许可</strong></li></ul><p>在上面的文字中，我使用了阻塞和唤醒，是为了和wait/notify做对比。其实park/unpark的设计原理核心是“许可”。park是等待一个许可。unpark是为某线程提供一个许可。如果某线程A调用park，那么除非另外一个线程调用unpark(A)给A一个许可，否则线程A将阻塞在park操作上。</p><p>有一点比较难理解的，是unpark操作可以再park操作之前。也就是说，先提供许可。当某线程调用park时，已经有许可了，它就消费这个许可，然后可以继续运行。这其实是必须的。考虑最简单的生产者(Producer)消费者(Consumer)模型：Consumer需要消费一个资源，于是调用park操作等待；Producer则生产资源，然后调用unpark给予Consumer使用的许可。非常有可能的一种情况是，Producer先生产，这时候Consumer可能还没有构造好（比如线程还没启动，或者还没切换到该线程）。那么等Consumer准备好要消费时，显然这时候资源已经生产好了，可以直接用，那么park操作当然可以直接运行下去。如果没有这个语义，那将非常难以操作。</p><ul><li><strong>其它细节</strong><br>理解了以上两点，我觉得应该把握了关键，其它细节就不是那么关键，也容易理解了，不作分析。</li></ul><h2 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h2><p>总结来说，Lock和synchronized有以下几点不同：</p><p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p><p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p><p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p><p>　　5）Lock可以提高多个线程进行读操作的效率。</p><p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;locks&quot;&gt;&lt;a href=&quot;#locks&quot; class=&quot;headerlink&quot; title=&quot;locks&quot;&gt;&lt;/a&gt;locks&lt;/h1&gt;&lt;p&gt;我们知道，synchronized 是Java的关键字，是Java的内置特性，在JVM层面实现了对临界资源的同步互斥
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.JUC/executor/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/5.JUC/executor/</id>
    <published>2019-02-21T03:42:05.522Z</published>
    <updated>2019-01-26T02:45:17.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Executors框架"><a href="#Executors框架" class="headerlink" title="Executors框架"></a>Executors框架</h1><p>前面我们已经学了如何通过继承Thread类或者实现Runnable接口来创建线程。</p><p>如果只是创建几个线程还好，如果要创建的线程数量比较多，那么这种不断创建和销毁线程的方法，其实是大大降低对系统资源的利用度的。</p><p>为了解决这个问题，JDK为我们提供了Executor框架，一个用来创建和管理线程的框架。</p><p>Executor框架具有以下的作用：</p><ul><li>创建线程：它提供了多种方法来创建线程，具体来说就是使用线程池维护线程，从线程池调用线程执行任务。</li><li>线程管理：通过线程池来维护线程的生命周期。</li><li>任务的提交与执行：它不仅提供了方法让你提交任务，还能让你决定任务是马上执行，还是延迟执行，甚至定期执行。</li></ul><p>JUC提供了以下三个接口，这三个接口定义所有创建和管理线程所需要的方法。</p><ul><li><strong>Executor</strong>：一个只包含<code>execute（）</code>方法的接口，通过接收一个<code>runnable</code>对象来执行任务。</li><li><strong>ExecutorService</strong>：<strong>Executor</strong>的子接口，添加了管理任务生命周期的功能。同时还提供了<code>submit()</code>方法可以接收<code>Runnable</code>和<code>Callable</code>对象。<code>Callable</code>与<code>Runnable</code>类似，只不过前者可以返回执行后的结果。</li><li><strong>ScheduledExecutorService</strong>：<strong>ExecutorService</strong>的子接口，It adds functionality to schedule the execution of the tasks.</li></ul><p>除了上面三个接口，JUC还提供了一个<code>Executors</code>类，提供了一些工厂方法来创建不同类型的<strong>ExecutorService</strong>。</p><h2 id="ExecutorService-Example"><a href="#ExecutorService-Example" class="headerlink" title="ExecutorService Example"></a>ExecutorService Example</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Creating Executor Service..."</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Creating a Runnable..."</span>);</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Submit the task."</span>);</span><br><span class="line">        executorService.submit(runnable);</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"Shutting down the executor"</span>);</span><br><span class="line">  executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside : "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Creating Executor Service with a thread pool of Size 2"</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Runnable task1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Executing Task1 inside : "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable task2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Executing Task2 inside : "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable task3 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Executing Task3 inside : "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Submitting the tasks for execution..."</span>);</span><br><span class="line">        executorService.submit(task1);</span><br><span class="line">        executorService.submit(task2);</span><br><span class="line">        executorService.submit(task3);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ScheduledExecutorService-example"><a href="#ScheduledExecutorService-example" class="headerlink" title="ScheduledExecutorService example"></a>ScheduledExecutorService example</h2><p>ScheduledExecutorService用来定期或者延期执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">   Runnable task = () -&gt; System.out.println(<span class="string">"老婆听电话！"</span>);</span><br><span class="line">   executorService.schedule(task, <span class="number">2</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">   Runnable task = () -&gt; System.out.println(<span class="string">"老婆听电话！"</span>);</span><br><span class="line">   executorService.scheduleAtFixedRate(task, <span class="number">2</span>, <span class="number">2</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Callable-And-Future"><a href="#Callable-And-Future" class="headerlink" title="Callable And Future"></a>Callable And Future</h1><p>在上面的例子，我们都是使用<code>Runnable</code>对象来定义任务，这种方法很方便，但是有个缺陷，那就是它不能返回任务执行后的结果。</p><p>JDK为我们提供了<code>Callable</code>接口用它来定义的任务，可以在执行完毕后返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">      <span class="comment">// Perform some computation</span></span><br><span class="line">      System.out.println(<span class="string">"Entered Callable"</span>);</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Hello from Callable"</span>;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">   Future&lt;String&gt; result = executorService.submit(task);</span><br><span class="line">   <span class="comment">// Future.get() blocks until the result is available</span></span><br><span class="line">   String s = result.get();</span><br><span class="line">   System.out.println(s);</span><br><span class="line">   executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h1><p>对生成新的异步任务和消费任务完成后的结果进行解耦。生产者提交需要被执行的任务，消费按顺序消费产物，先生产出来的，先消费。通常，CompletionService依赖于单独的Executor来实际执行任务，在这种情况下，CompletionService仅管理内部完成队列。 ExecutorCompletionService类提供了此方法的实现。</p><table><thead><tr><th></th><th>方法和描述</th></tr></thead><tbody><tr><td><code>Future&lt;V&gt;</code></td><td><code>poll()</code>Retrieves and removes the Future representing the next completed task, or <code>null</code> if none are present.</td></tr><tr><td><code>Future&lt;V&gt;</code></td><td><code>poll(long timeout, TimeUnit unit)</code>Retrieves and removes the Future representing the next completed task, waiting if necessary up to the specified wait time if none are yet present.</td></tr><tr><td><code>Future&lt;V&gt;</code></td><td><code>submit(Callable&lt;V&gt; task)</code>Submits a value-returning task for execution and returns a Future representing the pending results of the task.</td></tr><tr><td><code>Future&lt;V&gt;</code></td><td><code>submit(Runnable task, V result)</code>Submits a Runnable task for execution and returns a Future representing that task.</td></tr><tr><td><code>Future&lt;V&gt;</code></td><td><code>take()</code>Retrieves and removes the Future representing the next completed task, waiting if none are yet present.</td></tr></tbody></table><h2 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h2><p>一个CompletionService，它使用提供的Executor来执行任务。该类安排提交的任务在完成后放置在可使用take访问的队列中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Executors框架&quot;&gt;&lt;a href=&quot;#Executors框架&quot; class=&quot;headerlink&quot; title=&quot;Executors框架&quot;&gt;&lt;/a&gt;Executors框架&lt;/h1&gt;&lt;p&gt;前面我们已经学了如何通过继承Thread类或者实现Runnable接
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch11_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/5.JUC/atomic/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch11_多线程与并发编程/5.JUC/atomic/</id>
    <published>2019-02-21T03:42:05.522Z</published>
    <updated>2019-01-23T02:01:26.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-何谓Atomic？"><a href="#1-何谓Atomic？" class="headerlink" title="1.何谓Atomic？"></a>1.何谓Atomic？</h1><p> Atomic一词跟原子有点关系，后者曾被人认为是最小物质的单位。计算机中的Atomic是指不能分割成若干部分的意思。如果一段代码被认为是Atomic，则表示这段代码在执行过程中，是不能被中断的。通常来说，原子指令由硬件提供，供软件来实现原子方法（某个线程进入该方法后，就不会被中断，直到其执行完成）</p><p> 在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀”LOCK”，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。</p><h1 id="2-原子操作类"><a href="#2-原子操作类" class="headerlink" title="2.原子操作类"></a>2.原子操作类</h1><p>当多个线程同时更新公共变量，会导致线程不安全，通常大家可以会想到使用synchronized关键字或者Lock来解决这个问题，synchronized和Lock可以保证多个线程不会同时更新该公共变量。为了使用更简单，性能更高效，jdk1.5提出原子操作类。</p><p>原子操作类主要集中在Atomic（<code>java.util.concurrent.atomic</code>）包下，按照原子更新方式，这些原子操作类大致可以分为四种：原子更新基本类型、原子更新数组、原子更新引用以及原子更新属性，接下来就这四种类型原子操作类的具体实现做相关分析。</p><h2 id="2-1原子更新基本类型"><a href="#2-1原子更新基本类型" class="headerlink" title="2.1原子更新基本类型"></a>2.1原子更新基本类型</h2><p>Atomic包主要提供三个类来更新基本类型变量：</p><ul><li>AtomicBoolean：用来更新布尔型变量；</li><li>AtomicInteger：用来更新整型变量；</li><li>AtomicLong：用来更新长整型变量；</li></ul><h2 id="2-2原子更新数组"><a href="#2-2原子更新数组" class="headerlink" title="2.2原子更新数组"></a>2.2原子更新数组</h2><p>Atomic包提供三个类来以原子的方式更新数组里的元素：</p><ul><li>AtomicIntegerArray：用来更新整型数组里的元素；</li><li>AtomicLongArray：用来更新长整型数组里的元素；</li><li>AtomicReferenceArray：用来更新引用类型数组里的元素。</li></ul><h2 id="2-3原子更新引用类型"><a href="#2-3原子更新引用类型" class="headerlink" title="2.3原子更新引用类型"></a>2.3原子更新引用类型</h2><p>原子更新基本类型每次只能更新一个变量，假如需要更新多个变量怎么办呢？针对这个问题，Atomic包提供引用类型类来一次更新多个变量：</p><ul><li>AtomicReference：用于更新引用类型，可以理解为更新Object；</li><li>AtomicMarkableReference：用于更新带有标记位的引用类型；</li><li>AtomicStampedReference：用于更新带有版本号的引用类型，该类将版本号与引用类型关联起来，可以解决使用CAS进行原子更新时可能会出现的ABA问题。</li></ul><h2 id="2-4原子更新属性"><a href="#2-4原子更新属性" class="headerlink" title="2.4原子更新属性"></a>2.4原子更新属性</h2><p>AtomicReference系列可以更新Object，同样的，针对Object的属性，Atomic提供一下方法来更新Object的属性：</p><ul><li>AtomicIntegerFieldUpdater：用于更新Object的整型属性；</li><li>AtomicLongFieldUpdater：用于更新Object的长整型属性；</li><li>AtomicReferenceFieldUpdater：用于更新Object的引用类型属性。</li></ul><h1 id="3-原子操作类源码分析"><a href="#3-原子操作类源码分析" class="headerlink" title="3.原子操作类源码分析"></a>3.原子操作类源码分析</h1><h2 id="3-1原子更新基本类型"><a href="#3-1原子更新基本类型" class="headerlink" title="3.1原子更新基本类型"></a>3.1原子更新基本类型</h2><p>对于原子跟新基本类型，我们以AtomicLong为切入点，分析一下具体的源码实现。</p><p>AtomicLong有以下比较常用的方法： </p><ul><li><code>boolean compareAndSet(long expect, long update)</code></li><li><code>long getAndSet(long newValue)</code></li><li>add系列方法 <ul><li><code>long addAndGet(long delta)</code>和<code>long getAndAdd(long delta)</code></li></ul></li><li>increment系列方法 </li><li>decrement系列方法 </li><li><code>void lazySet(long newValue)</code></li></ul><p><strong>compareAndSet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了CAS机制：CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</span></span><br><span class="line"><span class="comment">// 调用Unsafe的compareAndSwapLong方法实现比较设置，如果当前value与预期值expect相等，则将value设置为update的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当对象是数组的时候，offset才有用的，如果其他，offset其实是没用的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">long</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>getAndSet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">long</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetLong(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSetLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, newValue));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>add系列方法 </strong></p><p>AtomicLong提供addAndGet方法和getAndAdd方法来做加法运算。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>increment系列方法 </strong></p><p>同add一样，AtomicLong同样提供两个方法：incrementAndGet和getAndIncrement方法来做自增操作。</p><p><strong>decrement系列方法 </strong></p><p>同样的，AtomicLong也提供两个方法：decrementAndGet和getAndDecrement方法来做自减操作。 </p><p><strong>lazySet方法 </strong></p><p><strong>练习</strong></p><p>实现自增计数器，要求线程安全。</p><h2 id="3-2原子更新数组"><a href="#3-2原子更新数组" class="headerlink" title="3.2原子更新数组"></a>3.2原子更新数组</h2><p>Atomic包提供三个类来以原子的方式更新数组里的元素：</p><ul><li>AtomicIntegerArray：用来更新整型数组里的元素；</li><li>AtomicLongArray：用来更新长整型数组里的元素；</li><li>AtomicReferenceArray：用来更新引用类型数组里的元素。</li></ul><p>接下来还是以AtomicLongArray为例，分析具体的源码实现。</p><p>AtomicLongArray同AtomicLong对外提供的方法大致一致，只不过前者是操作数组，后者是操作基本类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AtomicLongArray自己维护一个长整型数组array，对数组元素的操作实质是对array的操作。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] array;</span><br></pre></td></tr></table></figure><h2 id="3-3原子更新引用类型"><a href="#3-3原子更新引用类型" class="headerlink" title="3.3原子更新引用类型"></a>3.3原子更新引用类型</h2><p>原子更新基本类型每次只能更新一个变量，假如需要更新多个变量怎么办呢？针对这个问题，Atomic包提供引用类型类来一次更新多个变量：</p><ul><li>AtomicReference：用于更新引用类型，可以理解为更新Object；</li><li>AtomicMarkableReference：用于更新带有标记位的引用类型；</li><li>AtomicStampedReference：用于更新带有版本号的引用类型，该类将版本号与引用类型关联起来，可以解决使用CAS进行原子更新时可能会出现的ABA问题。</li></ul><h2 id="3-4原子更新属性"><a href="#3-4原子更新属性" class="headerlink" title="3.4原子更新属性"></a>3.4原子更新属性</h2><p>AtomicReference系列可以更新Object，同样的，针对Object的属性，Atomic提供一下方法来更新Object的属性：</p><ul><li>AtomicIntegerFieldUpdater：用于更新Object的整型属性；</li><li>AtomicLongFieldUpdater：用于更新Object的长整型属性；</li><li>AtomicReferenceFieldUpdater：用于更新Object的引用类型属性。</li></ul><p>以AtomicIntegerFieldUpdater为例，分析一下源码的具体实现。</p><p>在使用AtomicIntegerFieldUpdater来更改Object整型属性大致分为两步：</p><ol><li>使用静态方法newUpdater创建一个更新器，设置需要更新的类和属性；</li><li>调用相关CAS系列方法更新属性，<strong>需要注意的是，更新的属性必须使用public volatile修饰</strong>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-何谓Atomic？&quot;&gt;&lt;a href=&quot;#1-何谓Atomic？&quot; class=&quot;headerlink&quot; title=&quot;1.何谓Atomic？&quot;&gt;&lt;/a&gt;1.何谓Atomic？&lt;/h1&gt;&lt;p&gt; Atomic一词跟原子有点关系，后者曾被人认为是最小物质的单位。计
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch12_%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/Scanner/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch12_基础类库/Scanner/</id>
    <published>2019-02-21T03:41:58.398Z</published>
    <updated>2019-01-12T12:53:45.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><p>java.util.Scanner</p><p>A simple text scanner which can parse primitive(原始的) types and strings using regular expressions.</p><p>一个简单的文本扫描器,可以通过使用正则表达式解析基本数据类型和字符串,</p><p>primitive types : 基本数据类型</p><p>A Scanner breaks its input into tokens(记号) using a delimiter(分隔符) pattern,which by default matches whitespace.</p><p>The resulting tokens may then be converted into values of different types using the various next methods.</p><p>文本扫描器会根据你设置的分隔符,对输入的内容进行分隔,默认的分隔符是空格.</p><p>你可以通过使用各种各样的 next 方法来读取内容.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scanner&quot;&gt;&lt;a href=&quot;#Scanner&quot; class=&quot;headerlink&quot; title=&quot;Scanner&quot;&gt;&lt;/a&gt;Scanner&lt;/h1&gt;&lt;p&gt;java.util.Scanner&lt;/p&gt;
&lt;p&gt;A simple text scanner whi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch12_%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/7.2_%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch12_基础类库/7.2_系统相关/</id>
    <published>2019-02-21T03:41:58.398Z</published>
    <updated>2019-01-12T12:53:45.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h1><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>System类代表当前Java程序的运行平台,它是final修饰的类,你知道我在说什么吗? 就是它不能有子类.</p><p>它提供了代表标准输入 输出 和错误输出的类变量,</p><p>还提供了一些静态方法,用于访问环境变量、系统属性的方法、还提供了加载文件和动态链接库的方法.</p><p><strong>常用方法:</strong></p><p>① getenv() 以字典的形式返回系统所有环境变量</p><p>② getProperty(“”)获取系统属性</p><p>③getProperties()获取所有系统属性</p><p>④currentTimeMillis()返回long型整数格式的时间.</p><p>⑤identityHashCode(Object x) 获取某个对象的hashCode值. hashCode值相同,绝对是同一个对象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getenv();获取环境变量 getProperty("")获取系统属性 getProperties()获取系统所有属性.</span></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取系统所有的环境变量.</span></span><br><span class="line">Map&lt;String,String&gt; env = System.getenv();</span><br><span class="line"><span class="keyword">for</span> (String name: env.keySet())</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(name+<span class="string">":"</span>+env.get(name));</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 获取系统所有属性</span></span><br><span class="line">Properties props = System.getProperties();</span><br><span class="line">System.out.println(props);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h2><p>Runtime类代表着Java程序运行时环境,每个Java程序都有一个与之对应的Runtime实例.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统相关&quot;&gt;&lt;a href=&quot;#系统相关&quot; class=&quot;headerlink&quot; title=&quot;系统相关&quot;&gt;&lt;/a&gt;系统相关&lt;/h1&gt;&lt;h2 id=&quot;System类&quot;&gt;&lt;a href=&quot;#System类&quot; class=&quot;headerlink&quot; title=&quot;Sys
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch10_%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch10_注解/注解/</id>
    <published>2019-02-21T03:41:58.398Z</published>
    <updated>2019-01-12T12:53:45.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="自定义注解类型"><a href="#自定义注解类型" class="headerlink" title="自定义注解类型"></a>自定义注解类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotation</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span></span></span><br></pre></td></tr></table></figure><h3 id="标识型注解"><a href="#标识型注解" class="headerlink" title="标识型注解"></a>标识型注解</h3><p>注解体为空时，不包含任何成员的注解就是标识型注解。</p><h3 id="成员的可选类型"><a href="#成员的可选类型" class="headerlink" title="成员的可选类型"></a>成员的可选类型</h3><ul><li>String</li><li>Class</li><li>基本类型</li><li>枚举类型</li><li>注解类型</li><li>以及上述类型的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "默认构造方法"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">Class <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用于注解类的注解"><a href="#用于注解类的注解" class="headerlink" title="用于注解类的注解"></a>用于注解类的注解</h3><p>JDK内置了一些注解，让我们可以对自定义的注解类进行更加灵活的配置</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>指出该注解类适用于那些目标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "默认构造方法"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>ANNOTATION_TYPE</td><td>注解类型</td></tr><tr><td>TYPE</td><td>各种Java类型，包括类、接口、枚举类、注解类型</td></tr><tr><td>CONSTRUCTOR</td><td>构造方法</td></tr><tr><td>FIELD</td><td>成员变量</td></tr><tr><td>METHOD</td><td>成员方法</td></tr><tr><td>PARAMETER</td><td>方法参数</td></tr><tr><td>LOCAL_VARIABLE</td><td>局部变量</td></tr><tr><td>PACKAGE</td><td>包</td></tr></tbody></table><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>指定当前注解的有效范围</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>SOURCE</td><td>仅保存在源码中，不会引入到编译后的class文件中</td></tr><tr><td>CLASS</td><td>会把程序中对注解类型的引用编译到类文件中</td></tr><tr><td>RUNTIME</td><td>包含以上CLASS的范围，并且还能在运行时把注解加载到虚拟机中</td></tr></tbody></table><h4 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h4><p>标识型注解。表示注解类型包含的信息会被加入到<code>JavaDoc</code>文档中。</p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>表示该注解类可被继承</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>用于关闭编译时产生的特定警告信息</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>deprecation</td><td>使用了过时的类或方法的警告</td></tr><tr><td>unchecked</td><td>使用了未检查的类型转换的警告</td></tr><tr><td>fallthrough</td><td>switch语句中没有Break的警告</td></tr><tr><td>path</td><td></td></tr><tr><td>serial</td><td></td></tr><tr><td>final</td><td></td></tr><tr><td>all</td><td>以上所有警告</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h1&gt;&lt;h2 id=&quot;自定义注解类型&quot;&gt;&lt;a href=&quot;#自定义注解类型&quot; class=&quot;headerlink&quot; title=&quot;自定义注解类型&quot;&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch12_%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/7.3_%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch12_基础类库/7.3_常用类/</id>
    <published>2019-02-21T03:41:58.398Z</published>
    <updated>2019-01-12T12:53:45.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equlas</span><span class="params">(Object obj)</span></span>; <span class="comment">// 判断两个对象是否同一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>; <span class="comment">//当系统中没有引用变量引用到该对象时,垃圾回收器来该方法回收对象.</span></span><br><span class="line"><span class="function">Class&lt;T&gt; <span class="title">getClass</span><span class="params">()</span><span class="comment">//获取该对象的运行时类</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">// 返回该对象的hashCode值.结果默认跟System那个方法一致.</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span><span class="comment">//默认返回字符串,运行时类名@十六进制hashCode</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">clone</span><span class="params">()</span> <span class="comment">// 对对象进行浅克隆</span></span></span><br></pre></td></tr></table></figure><p>clone()方法</p><p>①自定义类实现Cloneable接口</p><p>②自定义类实现自己的clone()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (User) <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">User u1 = <span class="keyword">new</span> User();</span><br><span class="line">User u2 = u1.clone();</span><br><span class="line">System.out.println(u1 == u2); <span class="comment">//不是同一个对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><hr><h2 id="String、StringBuffer、StringBuilder类"><a href="#String、StringBuffer、StringBuilder类" class="headerlink" title="String、StringBuffer、StringBuilder类"></a>String、StringBuffer、StringBuilder类</h2><p>String类是不可变类.</p><p>StringBuffer类代表一个字符序列可变的字符串.该对象具有append() insert() reverse() setCharAt() setLength()等方法.</p><p>一旦通过StringBuffer类生成了最终想要的字符串,就可以通过toString()方法获得一个String对象.</p><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用类&quot;&gt;&lt;a href=&quot;#常用类&quot; class=&quot;headerlink&quot; title=&quot;常用类&quot;&gt;&lt;/a&gt;常用类&lt;/h1&gt;&lt;h2 id=&quot;Object类&quot;&gt;&lt;a href=&quot;#Object类&quot; class=&quot;headerlink&quot; title=&quot;Object类
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/Java/JavaSE/ch12_%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/7.1_%E4%B8%8E%E7%94%A8%E6%88%B7%E4%BA%92%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/02/21/Java/JavaSE/ch12_基础类库/7.1_与用户互动/</id>
    <published>2019-02-21T03:41:58.394Z</published>
    <updated>2019-01-12T12:53:45.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="与用户互动"><a href="#与用户互动" class="headerlink" title="与用户互动"></a>与用户互动</h1><h2 id="运行Java程序的参数"><a href="#运行Java程序的参数" class="headerlink" title="运行Java程序的参数"></a>运行Java程序的参数</h2><p>在运行Java程序时输入参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String arg : args)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------</span></span><br><span class="line"><span class="comment">// java Demo Hello World</span></span><br></pre></td></tr></table></figure><h2 id="使用Scanner获取键盘参数"><a href="#使用Scanner获取键盘参数" class="headerlink" title="使用Scanner获取键盘参数"></a>使用Scanner获取键盘参数</h2><p>Scanner类可以方便的获取用户的键盘输入,它是一个基于正则表达式的文本扫描器.</p><p>它可以从文件,输入流,字符串中解析出基本数据类型和字符串值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useDelimiter("定义分隔符"); hasNext();是否有内容; Next()输出内容; close(); 关闭扫描器</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    sc.useDelimiter(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(sc.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(sc.next());</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;与用户互动&quot;&gt;&lt;a href=&quot;#与用户互动&quot; class=&quot;headerlink&quot; title=&quot;与用户互动&quot;&gt;&lt;/a&gt;与用户互动&lt;/h1&gt;&lt;h2 id=&quot;运行Java程序的参数&quot;&gt;&lt;a href=&quot;#运行Java程序的参数&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/4.%E5%85%B6%E4%BB%96/4.%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/21/数据库/MySQL/4.其他/4.主从复制/</id>
    <published>2019-02-21T03:22:45.355Z</published>
    <updated>2019-02-20T22:33:35.152Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/gl-developer/p/6170423.html" target="_blank" rel="noopener">MySQL主从复制</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL数据库提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，也可以通过读写分离进一步提升数据库的负载性能。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p><p><strong>实现MySQL主从复制需要进行的配置：</strong></p><ul><li><p>主服务器：</p><ul><li>开启二进制日志</li><li>配置唯一的server-id</li><li>获得master二进制日志文件名及位置</li><li>创建一个用于slave和master通信的用户账号</li></ul></li><li><p>从服务器：</p><ul><li>配置唯一的server-id</li></ul></li><li><ul><li>使用master分配的用户账号读取master二进制日志</li><li>启用slave服务</li></ul></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>主数据库master修改：</p><p><strong>1.修改mysql配置</strong></p><p>找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin #开启二进制日志</span><br><span class="line">server-id=1 #设置server-id</span><br></pre></td></tr></table></figure><p><strong>2.重启mysql，创建用于同步的用户账号</strong></p><p>打开mysql会话shell&gt;mysql -hlocalhost -uname -ppassword</p><p>创建用户并授权：用户：rel1密码：slavepass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line">CREATE USER &apos;slaver&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class="line"># 分配权限</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &apos;slaver&apos;@&apos;%&apos;;</span><br><span class="line"># 刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p><strong>3.查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; SHOW MASTER STATUS;</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br><span class="line">| mysql-bin.000001 | 1026     |              |                  |</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br></pre></td></tr></table></figure><p>二、从服务器slave修改：</p><p><strong>1.修改mysql配置</strong></p><p>同样找到my.cnf配置文件，添加server-id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2 #设置server-id，必须唯一</span><br></pre></td></tr></table></figure><p><strong>2.重启mysql，打开mysql会话，执行同步SQL语句</strong>(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">change master to</span><br><span class="line">master_host=&apos;xxxxxx&apos;,</span><br><span class="line">master_user=&apos;slaver&apos;,</span><br><span class="line">master_password=&apos;123456&apos;,</span><br><span class="line">master_log_file=&apos;mysql-bin.000001&apos;,</span><br><span class="line">master_log_pos=1026;</span><br></pre></td></tr></table></figure><p><strong>3.启动slave同步进程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;start slave;</span><br></pre></td></tr></table></figure><p>4.查看slave状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"> ...</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">        ...</span><br><span class="line"># 当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</span><br></pre></td></tr></table></figure><p>master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 不同步哪些数据库  </span><br><span class="line">binlog-ignore-db = mysql  </span><br><span class="line">binlog-ignore-db = test  </span><br><span class="line">binlog-ignore-db = information_schema  </span><br><span class="line">  </span><br><span class="line"># 只同步哪些数据库，除此之外，其他不同步  </span><br><span class="line">binlog-do-db = game</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Slave-IO-Running-No"><a href="#Slave-IO-Running-No" class="headerlink" title="Slave_IO_Running:No"></a>Slave_IO_Running:No</h3><ol><li>设置从服务器的bind-address = *</li><li>主服务器的端口是否开放了</li><li>信息设置是否正确</li></ol><h3 id="Slave-SQL-Running-NO"><a href="#Slave-SQL-Running-NO" class="headerlink" title="Slave_SQL_Running:NO"></a>Slave_SQL_Running:NO</h3><p>Google…….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/gl-developer/p/6170423.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL主从复制&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/2.SpringDataRedis/"/>
    <id>http://yoursite.com/2019/02/21/数据库/Redis/2.SpringDataRedis/</id>
    <published>2019-02-21T03:22:45.355Z</published>
    <updated>2019-01-30T07:54:29.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-连接到Redis"><a href="#1-连接到Redis" class="headerlink" title="1.连接到Redis"></a>1.连接到Redis</h2><p><code>org.springframework.data.redis.connection</code>包提供了</p><ul><li><code>RedisConnection</code></li><li><code>RedisConnectionFactory</code></li></ul><p>这两个接口用来从Redis中获取connection。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.hdr.hello.redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> LettuceConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      RedisStandaloneConfiguration redisConf = <span class="keyword">new</span> RedisStandaloneConfiguration();</span><br><span class="line">      redisConf.setHostName(<span class="string">"localhost"</span>);</span><br><span class="line">      redisConf.setPort(<span class="number">6379</span>);</span><br><span class="line">      redisConf.setPassword(<span class="string">"!@#$"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LettuceConnectionFactory(redisConf);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RedisConnection connection = redisConnectionFactory.getConnection();</span><br><span class="line">   RedisStringCommands sc = connection.stringCommands();</span><br><span class="line">   sc.set(<span class="string">"name"</span>.getBytes(), <span class="string">"黄大仁"</span>.getBytes());</span><br><span class="line">   connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-RedisTemplate"><a href="#2-RedisTemplate" class="headerlink" title="2.RedisTemplate"></a>2.RedisTemplate</h2><p><code>RedisConnection</code>提供的方法都是对二进制数据进行操作，所以我们一般使用<code>RedisTemplate</code>来对Redis进行操作。</p><p><code>RedisTemplate</code>使用基于Java的序列化机制对对象或二进制数据进行序列化和反序列化。</p><p><code>org.springframework.data.redis.serializer</code>提供了其他的序列化机制。</p><p>You can also set any of the serializers to null and use RedisTemplate with raw byte arrays by setting the <code>enableDefaultSerializer</code> property to <code>false</code>. Note that the template requires all keys to be non-null. However, values can be null as long as the underlying serializer accepts them. Read the Javadoc of each serializer for more information.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RedisTemplate redisTemplate = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">   redisTemplate.setConnectionFactory(redisConnectionFactory());</span><br><span class="line">   <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line"><span class="keyword">private</span> ListOperations&lt;String, List&lt;String&gt;&gt; listOpts;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ArrayList&lt;String&gt; sList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   sList.add(<span class="string">"hello"</span>);</span><br><span class="line">   sList.add(<span class="string">"world"</span>);</span><br><span class="line">   listOpts.rightPush(<span class="string">"text"</span>, sList);</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; text = listOpts.leftPop(<span class="string">"text"</span>);</span><br><span class="line">   System.out.println(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>因为String用的多，所以特别提供了一个<code>StringRedisTemplate</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> StringRedisTemplate(redisConnectionFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ListOperations&lt;String, String&gt; listOpts = stringRedisTemplate.opsForList();</span><br><span class="line">   listOpts.rightPushAll(<span class="string">"books"</span>,<span class="string">"java 8 in action"</span>,<span class="string">"redis in action"</span>,<span class="string">"spring in action"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-序列化器"><a href="#3-序列化器" class="headerlink" title="3.序列化器"></a>3.序列化器</h2><p><code>org.springframework.data.redis.serializer</code>提供了两种类型的序列化器：</p><ul><li>Two-way serializers based on <code>RedisSerializer</code>.</li><li>Element readers and writers that use <code>RedisElementReader</code> and <code>RedisElementWriter</code>.</li></ul><p>The main difference between these variants is that <code>RedisSerializer</code> primarily serializes to <code>byte[]</code> while readers and writers use <code>ByteBuffer</code>.</p><p>Multiple implementations are available (including two that have been already mentioned in this documentation):</p><ul><li><code>JdkSerializationRedisSerializer</code>, which is used by default for <code>RedisCache</code> and <code>RedisTemplate</code>.</li><li>the <code>StringRedisSerializer</code>.</li></ul><p>However one can use <code>OxmSerializer</code> for Object/XML mapping through Spring <a href="https://docs.spring.io/spring/docs/5.1.4.RELEASE/spring-framework-reference/data-access.html#oxm" target="_blank" rel="noopener">OXM</a> support or <code>Jackson2JsonRedisSerializer</code> or <code>GenericJackson2JsonRedisSerializer</code> for storing data in <a href="https://en.wikipedia.org/wiki/JSON" target="_blank" rel="noopener">JSON</a> format.</p><p>Do note that the storage format is not limited only to values. It can be used for keys, values, or hashes without any restrictions.</p><h2 id="4-Hash-mapping"><a href="#4-Hash-mapping" class="headerlink" title="4.Hash mapping"></a>4.Hash mapping</h2><p>Spring Data Redis提供了各种将数据映射到哈希的策略。</p><ul><li>Using <code>HashMapper</code> and <code>HashOperations</code></li><li>Direct mapping, by using <code>HashOperations</code> and a <a href="https://docs.spring.io/spring-data/data-redis/docs/2.1.4.RELEASE/reference/html/#redis:serializer" target="_blank" rel="noopener">serializer</a></li><li>Using <a href="https://docs.spring.io/spring-data/data-redis/docs/2.1.4.RELEASE/reference/html/#redis.repositories" target="_blank" rel="noopener">Redis Repositories</a></li></ul><h3 id="4-1Hash-Mappers"><a href="#4-1Hash-Mappers" class="headerlink" title="4.1Hash Mappers"></a>4.1Hash Mappers</h3><ul><li><code>BeanUtilsHashMapper</code> using Spring’s <a href="https://docs.spring.io/spring/docs/5.1.4.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html" target="_blank" rel="noopener">BeanUtils</a>.</li><li><a href="https://docs.spring.io/spring-data/data-redis/docs/2.1.4.RELEASE/reference/html/#redis.hashmappers.jackson2" target="_blank" rel="noopener"><code>Jackson2HashMapper</code></a> using <a href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener">FasterXML Jackson</a>.</li><li><code>ObjectHashMapper</code> using <a href="https://docs.spring.io/spring-data/data-redis/docs/2.1.4.RELEASE/reference/html/#redis.repositories.mapping" target="_blank" rel="noopener">Object-to-Hash Mapping</a>.</li></ul><h4 id="ObjectHashMapper"><a href="#ObjectHashMapper" class="headerlink" title="ObjectHashMapper"></a>ObjectHashMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line">HashOperations&lt;String, <span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; hashOperations;</span><br><span class="line">HashMapper&lt;Object, <span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; hashMapper = <span class="keyword">new</span> ObjectHashMapper();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   String key = <span class="string">"person"</span>;</span><br><span class="line">   Person person = <span class="keyword">new</span> Person(<span class="string">"大仁"</span>, <span class="string">"黄"</span>);</span><br><span class="line">   Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; mappedHash = hashMapper.toHash(person);</span><br><span class="line">   hashOperations.putAll(key, mappedHash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   String key = <span class="string">"person"</span>;</span><br><span class="line">   Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; loadedHash = hashOperations.entries(key);</span><br><span class="line">   System.out.println(((Person) hashMapper.fromHash(loadedHash)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Jackson2HashMapper"><a href="#Jackson2HashMapper" class="headerlink" title="Jackson2HashMapper"></a>Jackson2HashMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RedisTemplate redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">   redisTemplate.setConnectionFactory(redisConnectionFactory());</span><br><span class="line">   <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">objectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jackson2HashMapper <span class="title">jackson2HashMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Jackson2HashMapper(objectMapper(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Jackson2HashMapper jackson2HashMapper;</span><br><span class="line">String key = <span class="string">"pig"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Person person = <span class="keyword">new</span> Person(<span class="string">"佩琪"</span>, <span class="string">"猪"</span>,<span class="keyword">new</span> Address(<span class="string">"GuangZhou"</span>, <span class="string">"China"</span>));</span><br><span class="line">   Map&lt;String, Object&gt; mappedHash = jackson2HashMapper.toHash(person);</span><br><span class="line">   hashOperations.putAll(key, mappedHash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Map&lt;String, Object&gt; entries = hashOperations.entries(key);</span><br><span class="line">   Object map = jackson2HashMapper.fromHash(entries);</span><br><span class="line">   Person person = <span class="keyword">new</span> ObjectMapper().convertValue(map, Person.class);</span><br><span class="line">   System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没用到其他序列化器也，同样也能实现把Json转化，不太懂0.0</p><h2 id="5-Redis-Repositories"><a href="#5-Redis-Repositories" class="headerlink" title="5.Redis Repositories"></a>5.Redis Repositories</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RedisHash</span>(<span class="string">"people"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span> String id;</span><br><span class="line">  String firstname;</span><br><span class="line">  String lastname;</span><br><span class="line">  Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Person</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 继承CrudRepository，获取基本的CRUD操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisRepositories</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> RedisTemplate&lt;?, ?&gt; redisTemplate() &#123;</span><br><span class="line">RedisTemplate&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">redisTemplate.setConnectionFactory(redisConnectionFactory());</span><br><span class="line"><span class="keyword">return</span> redisTemplate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line">PersonRepository repo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicCrudOperations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person rand = <span class="keyword">new</span> Person(<span class="string">"rand"</span>, <span class="string">"al'thor"</span>);</span><br><span class="line">  rand.setAddress(<span class="keyword">new</span> Address(<span class="string">"emond's field"</span>, <span class="string">"andor"</span>));</span><br><span class="line">  repo.save(rand);                                         </span><br><span class="line">  repo.findOne(rand.getId());                              </span><br><span class="line">  repo.count();                                            </span><br><span class="line">  repo.delete(rand);                                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-连接到Redis&quot;&gt;&lt;a href=&quot;#1-连接到Redis&quot; class=&quot;headerlink&quot; title=&quot;1.连接到Redis&quot;&gt;&lt;/a&gt;1.连接到Redis&lt;/h2&gt;&lt;p&gt;&lt;code&gt;org.springframework.data.redis.c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/1.Redis%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/21/数据库/Redis/1.Redis基础/</id>
    <published>2019-02-21T03:22:45.355Z</published>
    <updated>2019-02-19T10:55:08.458Z</updated>
    
    <content type="html"><![CDATA[<p>谈谈你对Redis的认识。</p><p>Redis是一个高性能的key-value数据库，它为我们提供了5种数据结构，分别是字符串、列表、哈希、有序集合、无序集合，常用的场景有session缓存、热点数据缓存、排行榜等等。Redis 提供了两种持久化方式:RDB（默认） 和AOF</p><h1 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h1><p><code>redis</code>为我们提供了5种数据结构</p><ul><li>String</li><li>list</li><li>hash</li><li>set</li><li>zset（有序集合）</li></ul><h2 id="String类型的CRUD"><a href="#String类型的CRUD" class="headerlink" title="String类型的CRUD"></a>String类型的CRUD</h2><p><code>Redis</code>的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 <code>ArrayList</code>，采用预分配冗余空间的方式来减少内存的频繁分配，当字符串长度小于<code>1M</code>时，扩容都是加倍现有的空间，如果超过 <code>1M</code>，扩容时一次只会多扩 <code>1M</code>的空间。需要注意的是字符串最大长度为 <code>512M</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加</span></span><br><span class="line"><span class="built_in">set</span> key value</span><br><span class="line">setnx key value</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">del key</span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line">exists key</span><br><span class="line">get key</span><br><span class="line"><span class="comment"># 批量处理</span></span><br><span class="line">mset key1 value1 key2 value2</span><br><span class="line">mget key1 key2 </span><br><span class="line"><span class="comment"># 过期</span></span><br><span class="line">expire key second</span><br><span class="line">setex key value second</span><br></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。</p><p>Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 右边进入</span></span><br><span class="line">rpush books python java golang</span><br><span class="line"><span class="comment"># 左边进入  这个有点反人类，一般从从右边进即可</span></span><br><span class="line">lpush books python java golang</span><br><span class="line"><span class="comment"># 右边出</span></span><br><span class="line">rpop books</span><br><span class="line"><span class="comment"># 左边出</span></span><br><span class="line">lpop books</span><br></pre></td></tr></table></figure><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hset books java <span class="string">"think in java"</span></span><br><span class="line">hset books golang <span class="string">"concurrency in go"</span></span><br><span class="line">hset books python <span class="string">"python cookbook"</span></span><br><span class="line"></span><br><span class="line">hget books golang</span><br><span class="line">hlen books</span><br><span class="line">hgetall books</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd books python</span><br><span class="line">smembers books</span><br><span class="line">sismember books java</span><br><span class="line">scard books  <span class="comment"># 获取长度相当于 count()</span></span><br><span class="line">spop books</span><br></pre></td></tr></table></figure><h2 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset(有序集合)"></a>zset(有序集合)</h2><p><code>zset</code>它类似于 Java 的 <code>SortedSet</code> 和 <code>HashMap</code> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。</p><p><code>zset</code>可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。</p><p><code>zset</code> 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zadd books 9.0 <span class="string">"think in java"</span></span><br><span class="line">zadd books 8.9 <span class="string">"java concurrency"</span></span><br><span class="line">zadd books 8.6 <span class="string">"java cookbook"</span></span><br><span class="line"></span><br><span class="line">zrange books 0 -1  <span class="comment"># 按 score 排序列出，参数区间为排名范围</span></span><br><span class="line">zrevrange books 0 -1  <span class="comment"># 按 score 逆序列出，参数区间为排名范围</span></span><br><span class="line"></span><br><span class="line">zcard books  <span class="comment"># 相当于 count()</span></span><br><span class="line"><span class="comment"># 获取指定 value 的 score score 使用 double 类型进行存储，所以存在小数点精度问题</span></span><br><span class="line">zscore books <span class="string">"java concurrency"</span> </span><br><span class="line"></span><br><span class="line">zrem books <span class="string">"java concurrency"</span></span><br></pre></td></tr></table></figure><h1 id="Redis的数据持久化"><a href="#Redis的数据持久化" class="headerlink" title="Redis的数据持久化"></a>Redis的数据持久化</h1><p>Redis提供两种机制实现数据的持久化，分别是RDB和AOF。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB是Redis DataBase的缩写，RDB是一个经过压缩的二进制文件，通过该文件可以还原生成RDB时的数据库状态。</p><p><strong>RDB的创建与载入</strong></p><p>有两个命令创建RDB文件，分别是SAVE、BGSAVE。</p><p>前者会阻塞Redis服务器进程，直到RDB文件创建完毕，后者则是创建一个子进程，由子进程生成RDB文件。</p><p>RDB文件的载入工作是在服务器启动时自动执行的，因为没有专门用于载入RDB文件的命令。载入RDB文件的期间，Redis服务器会处于阻塞状态。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF Append Only File，通过保存Redis服务器所执行的命令来记录数据库状态。</p><p>当AOF持久化功能打开后，服务器执行完一个命令后，会将指令添加到缓冲区，然后再把缓冲区中的数据写入到AOF文件。AOF文件会越来越大，Redis提供了一条执行让我们重写AOF文件，从而减少文件的大小 BGREWRITEAOF。</p><h1 id="Redis缓存常见问题"><a href="#Redis缓存常见问题" class="headerlink" title="Redis缓存常见问题"></a>Redis缓存常见问题</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存失效了，导致大量的请求发送到数据库上，导致数据库瘫痪。</p><p>发生的原因：1.Redis出故障挂掉了 2.对缓存数据设置相同的过期时间，导致某段时间内大量缓存失效。</p><p>对于Redis出故障<br>事发前：实现Redis的高可用，避免Redis挂掉这种情况的发生<br>事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)<br>事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</p><p>对于过期时间相近<br>在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>黑客特意请求缓存中不存在的数据，例如向ID为正数的表请求负数的ID，导致所有请求都发送到数据库上。</p><p>解决方案有两种：</p><p>1.使用布隆过滤器或者压缩filter提前拦截</p><p>2.当我们从数据库找不到的时候，我们也将这个<strong>空对象设置到缓存里边去</strong>。一般会为空对象设置一个<strong>较短的过期时间</strong>。</p><h2 id="缓存与数据库双写一致"><a href="#缓存与数据库双写一致" class="headerlink" title="缓存与数据库双写一致"></a>缓存与数据库双写一致</h2><p>数据更新的时候可能造成数据库和缓存的数据不一致。</p><p>一般来说，执行更新操作时，我们会有两种选择：</p><ul><li>先操作数据库，再操作缓存</li><li>先操作缓存，再操作数据库</li></ul><p>首先，要明确的是，无论我们选择哪个，我们都希望这<strong>两个操作要么同时成功，要么同时失败</strong>。所以，这会演变成一个<strong>分布式事务</strong>的问题。</p><p>所以，<strong>如果原子性被破坏了</strong>，可能会有以下的情况：</p><ul><li><strong>操作数据库成功了，操作缓存失败了</strong>。</li><li><strong>操作缓存成功了，操作数据库失败了</strong>。</li></ul><p>对于缓存，一般我们都是采取<strong>删除缓存</strong>缓存策略的，直接删除缓存，等再次读取时，到数据库找，在数据库找到再写到缓存里边。</p><p><strong>先更新数据库，再删除缓存</strong></p><ul><li>先操作数据库，成功；</li><li><p>再删除缓存，也成功；</p></li><li><p>如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。</p></li><li>第一步成功(操作数据库)，第二步失败(删除缓存)，会导致<strong>数据库里是新数据，而缓存里是旧数据</strong>。</li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NDA4OTk1OQ==&amp;mid=2649902243&amp;idx=1&amp;sn=ec8b267811f6fe83f1b77fb0e2ee9d24&amp;chksm=f31fbe2bc468373ddd477314b60da9469023c4312878df4743a2df37100676f748e873d742f6&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;pass_ticket=C2tn3mi3z0DiLURJ6AIw5pUlV%2BSGPc0J5htQ5vXmOu5J9uCACcLs6s1x5us3p%2BZf#rd" target="_blank" rel="noopener">具体看这里</a></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h1 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h1><h1 id="Redis有哪些架构？讲讲各自的特点"><a href="#Redis有哪些架构？讲讲各自的特点" class="headerlink" title="Redis有哪些架构？讲讲各自的特点"></a>Redis有哪些架构？讲讲各自的特点</h1><p><a href="https://www.cnblogs.com/jasontec/p/9699242.html" target="_blank" rel="noopener">https://www.cnblogs.com/jasontec/p/9699242.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;谈谈你对Redis的认识。&lt;/p&gt;
&lt;p&gt;Redis是一个高性能的key-value数据库，它为我们提供了5种数据结构，分别是字符串、列表、哈希、有序集合、无序集合，常用的场景有session缓存、热点数据缓存、排行榜等等。Redis 提供了两种持久化方式:RDB（默认） 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/4.%E5%85%B6%E4%BB%96/5.%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/21/数据库/MySQL/4.其他/5.用户管理/</id>
    <published>2019-02-21T03:22:45.355Z</published>
    <updated>2019-02-20T22:33:59.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-创建用户"><a href="#一-创建用户" class="headerlink" title="一. 创建用户"></a>一. 创建用户</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令:"></a>命令:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</span><br><span class="line"># username：你将创建的用户名</span><br><span class="line"># host：指定该用户在哪个主机上可以登陆，如果想让该用户可以从任意远程主机登陆，可以使用通配符`%`</span><br><span class="line"># password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</span><br></pre></td></tr></table></figure><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &apos;dog&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class="line">CREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos; IDENDIFIED BY &apos;123456&apos;;</span><br><span class="line">CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class="line">CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;;</span><br><span class="line">CREATE USER &apos;pig&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure><h2 id="二-授权"><a href="#二-授权" class="headerlink" title="二. 授权:"></a>二. 授权:</h2><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令:"></a>命令:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</span><br><span class="line"># privileges：用户的操作权限，如`SELECT`，`INSERT`，`UPDATE`等，如果要授予所的权限则使用`ALL`</span><br><span class="line"># databasename：数据库名  tablename：表名</span><br><span class="line"># 如果要授予该用户对所有数据库和表的相应操作权限则可用`*`表示，如`*.*`</span><br><span class="line">flush privileges; # 刷新权限</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;</span><br><span class="line">GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;;</span><br><span class="line">GRANT ALL ON maindataplus.* TO &apos;pig&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><h2 id="三-设置与更改用户密码"><a href="#三-设置与更改用户密码" class="headerlink" title="三.设置与更改用户密码"></a>三.设置与更改用户密码</h2><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令:"></a>命令:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);</span><br></pre></td></tr></table></figure><p>如果是当前登陆用户用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</span><br></pre></td></tr></table></figure><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子:"></a>例子:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &apos;pig&apos;@&apos;%&apos; = PASSWORD(&quot;123456&quot;);</span><br></pre></td></tr></table></figure><h2 id="四-撤销用户权限"><a href="#四-撤销用户权限" class="headerlink" title="四. 撤销用户权限"></a>四. 撤销用户权限</h2><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令:"></a>命令:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;;</span><br></pre></td></tr></table></figure><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子:"></a>例子:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT ON *.* FROM &apos;pig&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h3><p>假如你在给用户<code>&#39;pig&#39;@&#39;%&#39;</code>授权的时候是这样的（或类似的）：<code>GRANT SELECT ON test.user TO &#39;pig&#39;@&#39;%&#39;</code>，则在使用<code>REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;</code>命令并不能撤销该用户对test数据库中user表的<code>SELECT</code> 操作。相反，如果授权使用的是<code>GRANT SELECT ON *.* TO &#39;pig&#39;@&#39;%&#39;;</code>则<code>REVOKE SELECT ON test.user FROM &#39;pig&#39;@&#39;%&#39;;</code>命令也不能撤销该用户对test数据库中user表的<code>Select</code>权限。</p><p>具体信息可以用命令<code>SHOW GRANTS FOR &#39;pig&#39;@&#39;%&#39;;</code> 查看。</p><h2 id="五-删除用户"><a href="#五-删除用户" class="headerlink" title="五.删除用户"></a>五.删除用户</h2><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令:"></a>命令:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &apos;username&apos;@&apos;host&apos;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-创建用户&quot;&gt;&lt;a href=&quot;#一-创建用户&quot; class=&quot;headerlink&quot; title=&quot;一. 创建用户&quot;&gt;&lt;/a&gt;一. 创建用户&lt;/h2&gt;&lt;h3 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令:
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/3.RedisSession/"/>
    <id>http://yoursite.com/2019/02/21/数据库/Redis/3.RedisSession/</id>
    <published>2019-02-21T03:22:45.355Z</published>
    <updated>2019-02-16T13:20:19.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Redis-Session"><a href="#Spring-Redis-Session" class="headerlink" title="Spring Redis Session"></a>Spring Redis Session</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Spring Redis Session的工作原理就是，通过使用一个最高优先级的Filter，先对请求进行拦截，然后对请求和响应对象进行包装，从而使它们使用Redis记录Session。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.hdr.spring.session"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用于提供Redis连接</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LettuceConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     RedisStandaloneConfiguration conf = <span class="keyword">new</span> RedisStandaloneConfiguration(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">     conf.setPassword(<span class="string">"!@#$"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> LettuceConnectionFactory(conf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// redis序列化器</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer(om());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ObjectMapper <span class="title">om</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSessionInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractHttpSessionApplicationInitializer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SpringSessionInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 有两个构造方法，一个无参，一个Class&lt;?&gt;... configurationClasses </span></span><br><span class="line">     <span class="comment">// 这其中涉及到ContextLoaderListener的问题</span></span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Redis-Session&quot;&gt;&lt;a href=&quot;#Spring-Redis-Session&quot; class=&quot;headerlink&quot; title=&quot;Spring Redis Session&quot;&gt;&lt;/a&gt;Spring Redis Session&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
